{"metadata":"{\"defaultCompiler\":{\"version\":\"0.8.20\"},\"sources\":{\"contracts/PackAccount.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n// From with some modifications\\n// https://github.com/erc6551/reference/blob/main/src/examples/simple/SimpleERC6551Account.sol\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC1271.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\n\\nimport \\\"./lib/ERC6551Account.sol\\\";\\nimport \\\"./interfaces/IERC6551Account.sol\\\";\\nimport \\\"./interfaces/IERC6551Executable.sol\\\";\\n\\ncontract PackAccount is IERC165, IERC1271, IERC6551Account, IERC6551Executable {\\n    uint256 public state;\\n\\n    receive() external payable {}\\n\\n    function execute(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        uint256 operation\\n    ) public payable virtual returns (bytes memory result) {\\n        require(\\n            _isValidSigner(msg.sender),\\n            \\\"PackAccount: Only PackMain can call\\\"\\n        );\\n        require(\\n            operation == 0,\\n            \\\"PackAccount: Only call operations are supported\\\"\\n        );\\n\\n        ++state;\\n\\n        bool success;\\n        (success, result) = to.call{value: value}(data);\\n\\n        if (!success) {\\n            assembly {\\n                revert(add(result, 32), mload(result))\\n            }\\n        }\\n    }\\n\\n    function isValidSigner(\\n        address signer,\\n        bytes calldata\\n    ) public view virtual returns (bytes4) {\\n        if (_isValidSigner(signer)) {\\n            return IERC6551Account.isValidSigner.selector;\\n        }\\n\\n        return bytes4(0);\\n    }\\n\\n    function isValidSignature(\\n        bytes32 hash,\\n        bytes memory signature\\n    ) public view virtual returns (bytes4 magicValue) {\\n        bool isValid = SignatureChecker.isValidSignatureNow(\\n            owner(),\\n            hash,\\n            signature\\n        );\\n\\n        if (isValid) {\\n            return IERC1271.isValidSignature.selector;\\n        }\\n\\n        return \\\"\\\";\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public pure virtual returns (bool) {\\n        return (interfaceId == type(IERC165).interfaceId ||\\n            interfaceId == type(IERC6551Account).interfaceId ||\\n            interfaceId == type(IERC6551Executable).interfaceId);\\n    }\\n\\n    function token() public view virtual returns (uint256, address, uint256) {\\n        bytes memory footer = new bytes(0x60);\\n\\n        assembly {\\n            extcodecopy(address(), add(footer, 0x20), 0x4d, 0x60)\\n        }\\n\\n        return abi.decode(footer, (uint256, address, uint256));\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        (uint256 chainId, address tokenContract, uint256 tokenId) = token();\\n        if (chainId != block.chainid) return address(0);\\n\\n        return IERC721(tokenContract).ownerOf(tokenId);\\n    }\\n\\n    // Modified function to check if the signer is the token contract\\n    function _isValidSigner(\\n        address signer\\n    ) internal view virtual returns (bool) {\\n        (, address tokenContract, ) = token();\\n        return signer == tokenContract;\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"contracts/lib/ERC6551Bytecode.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// From:\\n// https://github.com/erc6551/reference/blob/main/src/lib/ERC6551BytecodeLib.sol\\n\\nlibrary ERC6551BytecodeLib {\\n    function getCreationCode(\\n        address implementation_,\\n        uint256 chainId_,\\n        address tokenContract_,\\n        uint256 tokenId_,\\n        uint256 salt_\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                hex\\\"3d60ad80600a3d3981f3363d3d373d3d3d363d73\\\",\\n                implementation_,\\n                hex\\\"5af43d82803e903d91602b57fd5bf3\\\",\\n                abi.encode(salt_, chainId_, tokenContract_, tokenId_)\\n            );\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.0\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Not enough balance for performing a CREATE2 deploy.\\n     */\\n    error Create2InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev There's no code to deploy.\\n     */\\n    error Create2EmptyBytecode();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error Create2FailedDeployment();\\n\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\\n        if (address(this).balance < amount) {\\n            revert Create2InsufficientBalance(address(this).balance, amount);\\n        }\\n        if (bytecode.length == 0) {\\n            revert Create2EmptyBytecode();\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        if (addr == address(0)) {\\n            revert Create2FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"contracts/lib/ERC6551Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// From:\\n// https://github.com/erc6551/reference/blob/main/src/lib/ERC6551AccountLib.sol\\n\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport \\\"./ERC6551Bytecode.sol\\\";\\n\\nlibrary ERC6551AccountLib {\\n    function computeAddress(\\n        address registry,\\n        address implementation,\\n        uint256 chainId,\\n        address tokenContract,\\n        uint256 tokenId,\\n        uint256 _salt\\n    ) internal pure returns (address) {\\n        bytes32 bytecodeHash = keccak256(\\n            ERC6551BytecodeLib.getCreationCode(\\n                implementation,\\n                chainId,\\n                tokenContract,\\n                tokenId,\\n                _salt\\n            )\\n        );\\n\\n        return Create2.computeAddress(bytes32(_salt), bytecodeHash, registry);\\n    }\\n\\n    function token() internal view returns (uint256, address, uint256) {\\n        bytes memory footer = new bytes(0x60);\\n\\n        assembly {\\n            // copy 0x60 bytes from end of footer\\n            extcodecopy(address(), add(footer, 0x20), 0x4d, 0x60)\\n        }\\n\\n        return abi.decode(footer, (uint256, address, uint256));\\n    }\\n\\n    function salt() internal view returns (uint256) {\\n        bytes memory footer = new bytes(0x20);\\n\\n        assembly {\\n            // copy 0x20 bytes from beginning of footer\\n            extcodecopy(address(), add(footer, 0x20), 0x2d, 0x20)\\n        }\\n\\n        return abi.decode(footer, (uint256));\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.0\"},\"contracts/interfaces/IERC6551Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @dev the ERC-165 identifier for this interface is `0x6faff5f1`\\ninterface IERC6551Account {\\n    /**\\n     * @dev Allows the account to receive Ether\\n     *\\n     * Accounts MUST implement a `receive` function\\n     *\\n     * Accounts MAY perform arbitrary logic to restrict conditions\\n     * under which Ether can be received\\n     */\\n    receive() external payable;\\n\\n    /**\\n     * @dev Returns the identifier of the non-fungible token which owns the account\\n     *\\n     * The return value of this function MUST be constant - it MUST NOT change over time\\n     *\\n     * @return chainId       The EIP-155 ID of the chain the token exists on\\n     * @return tokenContract The contract address of the token\\n     * @return tokenId       The ID of the token\\n     */\\n    function token()\\n        external\\n        view\\n        returns (uint256 chainId, address tokenContract, uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a value that SHOULD be modified each time the account changes state\\n     *\\n     * @return The current account state\\n     */\\n    function state() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a magic value indicating whether a given signer is authorized to act on behalf\\n     * of the account\\n     *\\n     * MUST return the bytes4 magic value 0x523e3260 if the given signer is valid\\n     *\\n     * By default, the holder of the non-fungible token the account is bound to MUST be considered\\n     * a valid signer\\n     *\\n     * Accounts MAY implement additional authorization logic which invalidates the holder as a\\n     * signer or grants signing permissions to other non-holder accounts\\n     *\\n     * @param  signer     The address to check signing authorization for\\n     * @param  context    Additional data used to determine whether the signer is valid\\n     * @return magicValue Magic value indicating whether the signer is valid\\n     */\\n    function isValidSigner(\\n        address signer,\\n        bytes calldata context\\n    ) external view returns (bytes4 magicValue);\\n}\\n\",\"versionPragma\":\"^0.8.0\"},\"contracts/interfaces/IERC6551Executable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @dev the ERC-165 identifier for this interface is `0x74420f4c`\\ninterface IERC6551Executable {\\n    /**\\n     * @dev Executes a low-level operation if the caller is a valid signer on the account\\n     *\\n     * Reverts and bubbles up error if operation fails\\n     *\\n     * @param to        The target address of the operation\\n     * @param value     The Ether value to be sent to the target\\n     * @param data      The encoded operation calldata\\n     * @param operation A value indicating the type of operation to perform\\n     *\\n     * Accounts implementing this interface MUST accept the following operation parameter values:\\n     * - 0 = CALL\\n     * - 1 = DELEGATECALL\\n     * - 2 = CREATE\\n     * - 3 = CREATE2\\n     *\\n     * Accounts implementing this interface MAY support additional operations or restrict a signer's\\n     * ability to execute certain operations\\n     *\\n     * @return The result of the operation\\n     */\\n    function execute(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        uint256 operation\\n    ) external payable returns (bytes memory);\\n}\\n\",\"versionPragma\":\"^0.8.0\"},\"@openzeppelin/contracts/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS\\n    }\\n\\n    /**\\n     * @dev The signature derives the `address(0)`.\\n     */\\n    error ECDSAInvalidSignature();\\n\\n    /**\\n     * @dev The signature has an invalid length.\\n     */\\n    error ECDSAInvalidSignatureLength(uint256 length);\\n\\n    /**\\n     * @dev The signature has an S value that is in the upper half order.\\n     */\\n    error ECDSAInvalidSignatureS(bytes32 s);\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\n     * and a bytes32 providing additional information about the error.\\n     *\\n     * If no error is returned, then the address can be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\\n        unchecked {\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\n            return tryRecover(hash, v, r, s);\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError, bytes32) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\n        }\\n\\n        return (signer, RecoverError.NoError, bytes32(0));\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\n     */\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert ECDSAInvalidSignature();\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert ECDSAInvalidSignatureS(errorArg);\\n        }\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ECDSA} from \\\"./ECDSA.sol\\\";\\nimport {IERC1271} from \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Safe Wallet (previously Gnosis Safe).\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"versionPragma\":\"^0.8.20\"}}}","address":"0x525623135a3414F69D7caB97252b7c7119e8B6A3","bytecode":"0x608060405234801561001057600080fd5b50611378806100206000396000f3fe6080604052600436106100745760003560e01c806374420f4c1161004e57806374420f4c146101375780638da5cb5b14610167578063c19d93fb14610192578063fc0c546a146101bd5761007b565b806301ffc9a7146100805780631626ba7e146100bd578063523e3260146100fa5761007b565b3661007b57005b600080fd5b34801561008c57600080fd5b506100a760048036038101906100a2919061099f565b6101ea565b6040516100b491906109e7565b60405180910390f35b3480156100c957600080fd5b506100e460048036038101906100df9190610b7e565b610324565b6040516100f19190610be9565b60405180910390f35b34801561010657600080fd5b50610121600480360381019061011c9190610cc2565b61035d565b60405161012e9190610be9565b60405180910390f35b610151600480360381019061014c9190610d58565b61038b565b60405161015e9190610e5f565b60405180910390f35b34801561017357600080fd5b5061017c6104b9565b6040516101899190610e90565b60405180910390f35b34801561019e57600080fd5b506101a7610563565b6040516101b49190610eba565b60405180910390f35b3480156101c957600080fd5b506101d2610569565b6040516101e193929190610ed5565b60405180910390f35b60007f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806102b557507f6faff5f1000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b8061031d57507f74420f4c000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b9050919050565b6000806103396103326104b9565b85856105e9565b9050801561035157631626ba7e60e01b915050610357565b60009150505b92915050565b600061036884610679565b1561037c5763523e326060e01b9050610384565b600060e01b90505b9392505050565b606061039633610679565b6103d5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103cc90610f8f565b60405180910390fd5b60008214610418576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161040f90611021565b60405180910390fd5b600080815461042690611070565b9190508190555060008673ffffffffffffffffffffffffffffffffffffffff168686866040516104579291906110e8565b60006040518083038185875af1925050503d8060008114610494576040519150601f19603f3d011682016040523d82523d6000602084013e610499565b606091505b508093508192505050806104af57815160208301fd5b5095945050505050565b6000806000806104c7610569565b9250925092504683146104e05760009350505050610560565b8173ffffffffffffffffffffffffffffffffffffffff16636352211e826040518263ffffffff1660e01b81526004016105199190610eba565b602060405180830381865afa158015610536573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055a9190611116565b93505050505b90565b60005481565b600080600080606067ffffffffffffffff81111561058a57610589610a53565b5b6040519080825280601f01601f1916602001820160405280156105bc5781602001600182028036833780820191505090505b5090506060604d60208301303c808060200190518101906105dd9190611196565b93509350935050909192565b60008060006105f885856106bf565b509150915060006003811115610611576106106111e9565b5b816003811115610624576106236111e9565b5b14801561065c57508573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b8061066e575061066d86868661071b565b5b925050509392505050565b600080610684610569565b509150508073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614915050919050565b600080600060418451036107045760008060006020870151925060408701519150606087015160001a90506106f68882858561083f565b955095509550505050610714565b60006002855160001b9250925092505b9250925092565b60008060008573ffffffffffffffffffffffffffffffffffffffff16858560405160240161074a929190611227565b604051602081830303815290604052631626ba7e60e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505060405161079c9190611288565b600060405180830381855afa9150503d80600081146107d7576040519150601f19603f3d011682016040523d82523d6000602084013e6107dc565b606091505b50915091508180156107f057506020815110155b80156108345750631626ba7e60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168180602001905181019061083291906112b4565b145b925050509392505050565b60008060007f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08460001c111561087f576000600385925092509250610929565b6000600188888888604051600081526020016040526040516108a494939291906112fd565b6020604051602081039080840390855afa1580156108c6573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361091a57600060016000801b93509350935050610929565b8060008060001b935093509350505b9450945094915050565b6000604051905090565b600080fd5b600080fd5b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b61097c81610947565b811461098757600080fd5b50565b60008135905061099981610973565b92915050565b6000602082840312156109b5576109b461093d565b5b60006109c38482850161098a565b91505092915050565b60008115159050919050565b6109e1816109cc565b82525050565b60006020820190506109fc60008301846109d8565b92915050565b6000819050919050565b610a1581610a02565b8114610a2057600080fd5b50565b600081359050610a3281610a0c565b92915050565b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b610a8b82610a42565b810181811067ffffffffffffffff82111715610aaa57610aa9610a53565b5b80604052505050565b6000610abd610933565b9050610ac98282610a82565b919050565b600067ffffffffffffffff821115610ae957610ae8610a53565b5b610af282610a42565b9050602081019050919050565b82818337600083830152505050565b6000610b21610b1c84610ace565b610ab3565b905082815260208101848484011115610b3d57610b3c610a3d565b5b610b48848285610aff565b509392505050565b600082601f830112610b6557610b64610a38565b5b8135610b75848260208601610b0e565b91505092915050565b60008060408385031215610b9557610b9461093d565b5b6000610ba385828601610a23565b925050602083013567ffffffffffffffff811115610bc457610bc3610942565b5b610bd085828601610b50565b9150509250929050565b610be381610947565b82525050565b6000602082019050610bfe6000830184610bda565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610c2f82610c04565b9050919050565b610c3f81610c24565b8114610c4a57600080fd5b50565b600081359050610c5c81610c36565b92915050565b600080fd5b600080fd5b60008083601f840112610c8257610c81610a38565b5b8235905067ffffffffffffffff811115610c9f57610c9e610c62565b5b602083019150836001820283011115610cbb57610cba610c67565b5b9250929050565b600080600060408486031215610cdb57610cda61093d565b5b6000610ce986828701610c4d565b935050602084013567ffffffffffffffff811115610d0a57610d09610942565b5b610d1686828701610c6c565b92509250509250925092565b6000819050919050565b610d3581610d22565b8114610d4057600080fd5b50565b600081359050610d5281610d2c565b92915050565b600080600080600060808688031215610d7457610d7361093d565b5b6000610d8288828901610c4d565b9550506020610d9388828901610d43565b945050604086013567ffffffffffffffff811115610db457610db3610942565b5b610dc088828901610c6c565b93509350506060610dd388828901610d43565b9150509295509295909350565b600081519050919050565b600082825260208201905092915050565b60005b83811015610e1a578082015181840152602081019050610dff565b60008484015250505050565b6000610e3182610de0565b610e3b8185610deb565b9350610e4b818560208601610dfc565b610e5481610a42565b840191505092915050565b60006020820190508181036000830152610e798184610e26565b905092915050565b610e8a81610c24565b82525050565b6000602082019050610ea56000830184610e81565b92915050565b610eb481610d22565b82525050565b6000602082019050610ecf6000830184610eab565b92915050565b6000606082019050610eea6000830186610eab565b610ef76020830185610e81565b610f046040830184610eab565b949350505050565b600082825260208201905092915050565b7f5061636b4163636f756e743a204f6e6c79205061636b4d61696e2063616e206360008201527f616c6c0000000000000000000000000000000000000000000000000000000000602082015250565b6000610f79602383610f0c565b9150610f8482610f1d565b604082019050919050565b60006020820190508181036000830152610fa881610f6c565b9050919050565b7f5061636b4163636f756e743a204f6e6c792063616c6c206f7065726174696f6e60008201527f732061726520737570706f727465640000000000000000000000000000000000602082015250565b600061100b602f83610f0c565b915061101682610faf565b604082019050919050565b6000602082019050818103600083015261103a81610ffe565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061107b82610d22565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036110ad576110ac611041565b5b600182019050919050565b600081905092915050565b60006110cf83856110b8565b93506110dc838584610aff565b82840190509392505050565b60006110f58284866110c3565b91508190509392505050565b60008151905061111081610c36565b92915050565b60006020828403121561112c5761112b61093d565b5b600061113a84828501611101565b91505092915050565b60008151905061115281610d2c565b92915050565b600061116382610c04565b9050919050565b61117381611158565b811461117e57600080fd5b50565b6000815190506111908161116a565b92915050565b6000806000606084860312156111af576111ae61093d565b5b60006111bd86828701611143565b93505060206111ce86828701611181565b92505060406111df86828701611143565b9150509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b61122181610a02565b82525050565b600060408201905061123c6000830185611218565b818103602083015261124e8184610e26565b90509392505050565b600061126282610de0565b61126c81856110b8565b935061127c818560208601610dfc565b80840191505092915050565b60006112948284611257565b915081905092915050565b6000815190506112ae81610a0c565b92915050565b6000602082840312156112ca576112c961093d565b5b60006112d88482850161129f565b91505092915050565b600060ff82169050919050565b6112f7816112e1565b82525050565b60006080820190506113126000830187611218565b61131f60208301866112ee565b61132c6040830185611218565b6113396060830184611218565b9594505050505056fea26469706673582212201a63742e86eeb5a2e0d046e913705ff5453e6269341760c57bf5d71a1d916ab964736f6c63430008140033","deployedBytecode":"0x6080604052600436106100745760003560e01c806374420f4c1161004e57806374420f4c146101375780638da5cb5b14610167578063c19d93fb14610192578063fc0c546a146101bd5761007b565b806301ffc9a7146100805780631626ba7e146100bd578063523e3260146100fa5761007b565b3661007b57005b600080fd5b34801561008c57600080fd5b506100a760048036038101906100a2919061099f565b6101ea565b6040516100b491906109e7565b60405180910390f35b3480156100c957600080fd5b506100e460048036038101906100df9190610b7e565b610324565b6040516100f19190610be9565b60405180910390f35b34801561010657600080fd5b50610121600480360381019061011c9190610cc2565b61035d565b60405161012e9190610be9565b60405180910390f35b610151600480360381019061014c9190610d58565b61038b565b60405161015e9190610e5f565b60405180910390f35b34801561017357600080fd5b5061017c6104b9565b6040516101899190610e90565b60405180910390f35b34801561019e57600080fd5b506101a7610563565b6040516101b49190610eba565b60405180910390f35b3480156101c957600080fd5b506101d2610569565b6040516101e193929190610ed5565b60405180910390f35b60007f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806102b557507f6faff5f1000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b8061031d57507f74420f4c000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b9050919050565b6000806103396103326104b9565b85856105e9565b9050801561035157631626ba7e60e01b915050610357565b60009150505b92915050565b600061036884610679565b1561037c5763523e326060e01b9050610384565b600060e01b90505b9392505050565b606061039633610679565b6103d5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103cc90610f8f565b60405180910390fd5b60008214610418576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161040f90611021565b60405180910390fd5b600080815461042690611070565b9190508190555060008673ffffffffffffffffffffffffffffffffffffffff168686866040516104579291906110e8565b60006040518083038185875af1925050503d8060008114610494576040519150601f19603f3d011682016040523d82523d6000602084013e610499565b606091505b508093508192505050806104af57815160208301fd5b5095945050505050565b6000806000806104c7610569565b9250925092504683146104e05760009350505050610560565b8173ffffffffffffffffffffffffffffffffffffffff16636352211e826040518263ffffffff1660e01b81526004016105199190610eba565b602060405180830381865afa158015610536573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055a9190611116565b93505050505b90565b60005481565b600080600080606067ffffffffffffffff81111561058a57610589610a53565b5b6040519080825280601f01601f1916602001820160405280156105bc5781602001600182028036833780820191505090505b5090506060604d60208301303c808060200190518101906105dd9190611196565b93509350935050909192565b60008060006105f885856106bf565b509150915060006003811115610611576106106111e9565b5b816003811115610624576106236111e9565b5b14801561065c57508573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b8061066e575061066d86868661071b565b5b925050509392505050565b600080610684610569565b509150508073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614915050919050565b600080600060418451036107045760008060006020870151925060408701519150606087015160001a90506106f68882858561083f565b955095509550505050610714565b60006002855160001b9250925092505b9250925092565b60008060008573ffffffffffffffffffffffffffffffffffffffff16858560405160240161074a929190611227565b604051602081830303815290604052631626ba7e60e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505060405161079c9190611288565b600060405180830381855afa9150503d80600081146107d7576040519150601f19603f3d011682016040523d82523d6000602084013e6107dc565b606091505b50915091508180156107f057506020815110155b80156108345750631626ba7e60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168180602001905181019061083291906112b4565b145b925050509392505050565b60008060007f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08460001c111561087f576000600385925092509250610929565b6000600188888888604051600081526020016040526040516108a494939291906112fd565b6020604051602081039080840390855afa1580156108c6573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361091a57600060016000801b93509350935050610929565b8060008060001b935093509350505b9450945094915050565b6000604051905090565b600080fd5b600080fd5b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b61097c81610947565b811461098757600080fd5b50565b60008135905061099981610973565b92915050565b6000602082840312156109b5576109b461093d565b5b60006109c38482850161098a565b91505092915050565b60008115159050919050565b6109e1816109cc565b82525050565b60006020820190506109fc60008301846109d8565b92915050565b6000819050919050565b610a1581610a02565b8114610a2057600080fd5b50565b600081359050610a3281610a0c565b92915050565b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b610a8b82610a42565b810181811067ffffffffffffffff82111715610aaa57610aa9610a53565b5b80604052505050565b6000610abd610933565b9050610ac98282610a82565b919050565b600067ffffffffffffffff821115610ae957610ae8610a53565b5b610af282610a42565b9050602081019050919050565b82818337600083830152505050565b6000610b21610b1c84610ace565b610ab3565b905082815260208101848484011115610b3d57610b3c610a3d565b5b610b48848285610aff565b509392505050565b600082601f830112610b6557610b64610a38565b5b8135610b75848260208601610b0e565b91505092915050565b60008060408385031215610b9557610b9461093d565b5b6000610ba385828601610a23565b925050602083013567ffffffffffffffff811115610bc457610bc3610942565b5b610bd085828601610b50565b9150509250929050565b610be381610947565b82525050565b6000602082019050610bfe6000830184610bda565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610c2f82610c04565b9050919050565b610c3f81610c24565b8114610c4a57600080fd5b50565b600081359050610c5c81610c36565b92915050565b600080fd5b600080fd5b60008083601f840112610c8257610c81610a38565b5b8235905067ffffffffffffffff811115610c9f57610c9e610c62565b5b602083019150836001820283011115610cbb57610cba610c67565b5b9250929050565b600080600060408486031215610cdb57610cda61093d565b5b6000610ce986828701610c4d565b935050602084013567ffffffffffffffff811115610d0a57610d09610942565b5b610d1686828701610c6c565b92509250509250925092565b6000819050919050565b610d3581610d22565b8114610d4057600080fd5b50565b600081359050610d5281610d2c565b92915050565b600080600080600060808688031215610d7457610d7361093d565b5b6000610d8288828901610c4d565b9550506020610d9388828901610d43565b945050604086013567ffffffffffffffff811115610db457610db3610942565b5b610dc088828901610c6c565b93509350506060610dd388828901610d43565b9150509295509295909350565b600081519050919050565b600082825260208201905092915050565b60005b83811015610e1a578082015181840152602081019050610dff565b60008484015250505050565b6000610e3182610de0565b610e3b8185610deb565b9350610e4b818560208601610dfc565b610e5481610a42565b840191505092915050565b60006020820190508181036000830152610e798184610e26565b905092915050565b610e8a81610c24565b82525050565b6000602082019050610ea56000830184610e81565b92915050565b610eb481610d22565b82525050565b6000602082019050610ecf6000830184610eab565b92915050565b6000606082019050610eea6000830186610eab565b610ef76020830185610e81565b610f046040830184610eab565b949350505050565b600082825260208201905092915050565b7f5061636b4163636f756e743a204f6e6c79205061636b4d61696e2063616e206360008201527f616c6c0000000000000000000000000000000000000000000000000000000000602082015250565b6000610f79602383610f0c565b9150610f8482610f1d565b604082019050919050565b60006020820190508181036000830152610fa881610f6c565b9050919050565b7f5061636b4163636f756e743a204f6e6c792063616c6c206f7065726174696f6e60008201527f732061726520737570706f727465640000000000000000000000000000000000602082015250565b600061100b602f83610f0c565b915061101682610faf565b604082019050919050565b6000602082019050818103600083015261103a81610ffe565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061107b82610d22565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036110ad576110ac611041565b5b600182019050919050565b600081905092915050565b60006110cf83856110b8565b93506110dc838584610aff565b82840190509392505050565b60006110f58284866110c3565b91508190509392505050565b60008151905061111081610c36565b92915050565b60006020828403121561112c5761112b61093d565b5b600061113a84828501611101565b91505092915050565b60008151905061115281610d2c565b92915050565b600061116382610c04565b9050919050565b61117381611158565b811461117e57600080fd5b50565b6000815190506111908161116a565b92915050565b6000806000606084860312156111af576111ae61093d565b5b60006111bd86828701611143565b93505060206111ce86828701611181565b92505060406111df86828701611143565b9150509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b61122181610a02565b82525050565b600060408201905061123c6000830185611218565b818103602083015261124e8184610e26565b90509392505050565b600061126282610de0565b61126c81856110b8565b935061127c818560208601610dfc565b80840191505092915050565b60006112948284611257565b915081905092915050565b6000815190506112ae81610a0c565b92915050565b6000602082840312156112ca576112c961093d565b5b60006112d88482850161129f565b91505092915050565b600060ff82169050919050565b6112f7816112e1565b82525050565b60006080820190506113126000830187611218565b61131f60208301866112ee565b61132c6040830185611218565b6113396060830184611218565b9594505050505056fea26469706673582212201a63742e86eeb5a2e0d046e913705ff5453e6269341760c57bf5d71a1d916ab964736f6c63430008140033","abi":[{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"uint256","name":"operation","type":"uint256"}],"name":"execute","outputs":[{"internalType":"bytes","name":"result","type":"bytes"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"hash","type":"bytes32"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"isValidSignature","outputs":[{"internalType":"bytes4","name":"magicValue","type":"bytes4"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"bytes","name":"","type":"bytes"}],"name":"isValidSigner","outputs":[{"internalType":"bytes4","name":"","type":"bytes4"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"state","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"stateMutability":"payable","type":"receive"}]}